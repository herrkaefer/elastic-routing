/*  =========================================================================
    tsp - implementation

    Copyright (c) 2016, Yang LIU <gloolar@gmail.com>
    =========================================================================
*/

#include "classes.h"


#define SMALL_NUM_NODES 10


struct _tsp_t {
    vrp_t *vrp; // reference of generic model
    route_t *template; // route template
    size_t start_node_id;
    size_t end_node_id;
    rng_t *rng;
};


// Check that round or one-way trip is to be optimized
static bool tsp_is_round_trip (tsp_t *self) {
    return (self->start_node_id != ID_NONE &&
            self->end_node_id != ID_NONE &&
            self->start_node_id == self->end_node_id);
}


// Number of different nodes for optimize
static size_t tsp_num_nodes (tsp_t *self) {
    return tsp_is_round_trip (self) ?
           listu_size (self->template) - 1 :
           listu_size (self->template);
}


// Fitness callback: inverse of average cost over arcs
static double tsp_fitness (tsp_t *self, route_t *route) {
    double dist = route_total_distance (route, self->vrp);
    return (dist > 0) ?
           (route_size (route) - 1) / dist :
           0.0;
}


// Distance callback (Levenshtein distance)
static double tsp_distance (tsp_t *self,
                            route_t *r1,
                            route_t *r2) {
    return arrayu_levenshtein_distance (route_node_array (r1), route_size (r1),
                                        route_node_array (r2), route_size (r2));
}


// Heuristic: Sweep algorithm
// @todo could be modified to generate more (realistic) routes
static listx_t *tsp_sweep (tsp_t *self, size_t max_expected) {
    listx_t *list = listx_new ();

    size_t route_len = route_size (self->template);
    size_t idx_begin = (self->start_node_id != ID_NONE) ? 1 : 0;
    size_t idx_end = (self->end_node_id != ID_NONE) ?
                     (route_len - 2) :
                     (route_len - 1);
    size_t num_nodes_to_sort = idx_end - idx_begin + 1;

    // size_t num_nodes = tsp_num_nodes (self);

    // Get polar coordinates of nodes to sort
    coord2d_t *polars =
        (coord2d_t *) malloc (sizeof (coord2d_t) * num_nodes_to_sort);
    assert (polars);

    const coord2d_t *ref = (self->start_node_id != ID_NONE) ?
                           vrp_node_coord (self->vrp, self->start_node_id) :
                           NULL;

    for (size_t idx = idx_begin; idx <= idx_end; idx++) {
        size_t node_id = route_at (self->template, idx);
        polars[idx] = coord2d_to_polar (vrp_node_coord (self->vrp, node_id),
                                        ref,
                                        vrp_coord_sys (self->vrp));
        polars[idx].v1 = (double) node_id; // save ID in radius position
    }

    // Sort nodes in ascending order of angle
    qsort (polars, num_nodes_to_sort, sizeof (coord2d_t),
           (comparator_t) coord2d_compare_polar_angle);

    // Make route
    listu_t *route = route_new (route_len);
    assert (route);
    if (self->start_node_id != SIZE_NONE)
        route_append_node (route, self->start_node_id);
    for (size_t idx = 0; idx < num_nodes_to_sort; idx++)
        route_append_node (route, (size_t) polars[idx].v1);
    if (self->end_node_id != SIZE_NONE)
        route_append_node (route, self->end_node_id);

    print_info ("route generated by sweep:\n");
    route_print (route);

    listx_append (list, route);
    return list;
}


// Heuristic: random permutation
static listx_t *tsp_random_permutation (tsp_t *self, size_t max_expected) {
    listx_t *list = listx_new ();

    size_t route_len = route_size (self->template);
    size_t shuffle_begin = (self->start_node_id != ID_NONE) ? 1 : 0;
    size_t shuffle_end =
        (self->end_node_id != ID_NONE) ? (route_len - 2) : (route_len - 1);
    assert (shuffle_begin <= shuffle_end);

    // Duplate template and shuffle
    for (size_t cnt = 0; cnt < max_expected; cnt++) {
        route_t *route = route_dup (self->template);
        assert (route);
        route_shuffle (route, shuffle_begin, shuffle_end, self->rng);
        listx_append (list, route);
    }

    return list;
}


// Crossover: OX
static listx_t *tsp_ox (tsp_t *self, route_t *route1, route_t *route2) {
    assert (route_size (route1) == route_size (route2));
    route_t *r1 = route_dup (route1);
    route_t *r2 = route_dup (route2);

    size_t idx_begin = self->start_node_id != ID_NONE ? 1 : 0;
    size_t idx_end = route_size (route1) -
                     ((self->end_node_id != ID_NONE) ? 2 : 1);
    route_ox (r1, r2, idx_begin, idx_end, self->rng);

    listx_t *list = listx_new ();
    listx_append (list, r1);
    listx_append (list, r2);
    return list;
}


static double tsp_2_opt (tsp_t *self, route_t *route) {
    print_info ("tsp 2-opt start.\n");
    size_t idx_begin = (self->start_node_id != ID_NONE) ? 1 : 0;
    size_t idx_end = route_size (route) -
                     ((self->end_node_id != ID_NONE) ? 2 : 1);
    print_info ("idx_begin: %zu, idx_end: %zu\n", idx_begin, idx_end);
    return route_2_opt (route, self->vrp, idx_begin, idx_end);
}


// Solve small model
static solution_t *tsp_solve_small_model (tsp_t *self) {
    print_info ("solve a small model...\n");
    solution_t *sol = solution_new (NULL);
    size_t num_nodes = tsp_num_nodes (self);

    // Case 1: no nodes
    if (num_nodes == 0)
        return sol; // empty solution

    // Case 2: one node
    // Case 3: two nodes, and at least one node is fixed
    if (num_nodes == 1 ||
          (num_nodes == 2 &&
          (self->start_node_id != ID_NONE || self->end_node_id != ID_NONE)) ) {
        route_t *route = route_dup (self->template);
        solution_add_route (sol, route);
        return sol;
    }

    // Other small cases: use local search to solve.
    route_t *route = route_dup (self->template);
    double route_cost = route_total_distance (route, self->vrp);
    print_info ("route cost before local search: %.2f\n", route_cost);
    double delta_cost = tsp_2_opt (self, route);
    double improvement = -delta_cost / route_cost;
    route_cost = route_total_distance (route, self->vrp);
    print_info ("route cost after local search: %.2f (%+.2f%% improved)\n",
                route_cost, improvement * 100);

    solution_add_route (sol, route);
    return sol;
}


// ----------------------------------------------------------------------------

tsp_t *tsp_new_from (vrp_t *vrp) {
    assert (vrp);

    // Sub-model verification
    if (!vrp_is_tsp (vrp)) {
        print_error ("TSP submodel verification failed.\n");
        return NULL;
    }

    tsp_t *self = (tsp_t *) malloc (sizeof (tsp_t));
    assert (self);

    self->vrp = vrp;

    // Set start and end nodes
    size_t vehicle_id = listu_get (vrp_vehicle_ids (vrp), 0);
    assert (vehicle_id != ID_NONE);

    self->start_node_id = vrp_vehicle_start_node_id (vrp, vehicle_id);
    self->end_node_id = vrp_vehicle_end_node_id (vrp, vehicle_id);

    // Make regularized route template: (start_node_id, ..., end_node_id)
    // Note that start or end node of vehicle may not be specified, then the
    // model is one-way and open ended.
    size_t num_nodes = vrp_num_nodes (vrp);
    self->template = route_new (num_nodes + 1);
    const listu_t *node_ids = vrp_node_ids (vrp);
    assert (node_ids);
    // assert (listu_size (node_ids) == num_nodes);

    if (self->start_node_id != ID_NONE)
        listu_append (self->template, self->start_node_id);
    for (size_t cnt = 0; cnt < num_nodes; cnt++) {
        size_t node_id = listu_get (node_ids, cnt);
        if (node_id != self->start_node_id &&
            node_id != self->end_node_id) {
            listu_append (self->template, node_id);
        }
    }
    if (self->end_node_id != ID_NONE)
        listu_append (self->template, self->end_node_id);

    print_info ("tsp derived from generic VRP model.\n");
    print_info ("route template: #nodes: %zu, %s trip\n",
                tsp_num_nodes (self),
                tsp_is_round_trip (self) ? "round" : "one-way");
    route_print (self->template);

    self->rng = rng_new ();
    return self;
}


void tsp_free (tsp_t **self_p) {
    assert (self_p);
    if (*self_p) {
        tsp_t *self = *self_p;
        route_free (&self->template);
        rng_free (&self->rng);
        free (self);
        *self_p = NULL;
    }
    print_info ("tsp freed.\n");
}


solution_t *tsp_solve (tsp_t *self) {
    assert (self);

    // Deal with small numboer of nodes
    if (tsp_num_nodes (self) <= SMALL_NUM_NODES)
        return tsp_solve_small_model (self);

    // Create evolution object
    evol_t *evol = evol_new ();

    // Set context
    evol_set_context (evol, self);

    // Set all necessary callbacks
    evol_set_genome_destructor (evol, (destructor_t) route_free);
    evol_set_genome_printer (evol, (printer_t) route_print);
    evol_set_fitness_assessor (evol, (evol_fitness_assessor_t) tsp_fitness);
    evol_set_distance_assessor (evol, (evol_distance_assessor_t) tsp_distance);

    if (vrp_coord_sys (self->vrp) != CS_NONE)
        evol_register_heuristic (evol,
                                 (evol_heuristic_t) tsp_sweep,
                                 false,
                                 1);

    size_t num_free_nodes = route_size (self->template);
    num_free_nodes -= (self->start_node_id != ID_NONE) ? 1 : 0;
    num_free_nodes -= (self->end_node_id != ID_NONE) ? 1 : 0;
    evol_register_heuristic (evol,
                             (evol_heuristic_t) tsp_random_permutation,
                             true,
                             factorial (num_free_nodes));

    evol_register_crossover (evol, (evol_crossover_t) tsp_ox);

    // Run evolution
    evol_run (evol);

    // Get best route
    route_t *route = route_dup ((route_t *) evol_best_genome (evol));
    assert (route);

    // Destroy evolution object
    evol_free (&evol);

    double route_cost = route_total_distance (route, self->vrp);
    print_info ("route cost after evol: %.2f\n", route_cost);

    // Post optimization
    double delta_cost = tsp_2_opt (self, route);
    double improvement = -delta_cost / route_cost;
    route_cost = route_total_distance (route, self->vrp);
    print_info ("route cost after post-optimization: %.2f\n", route_cost);
    print_info ("post-optimization improved: %.2f%%\n", improvement * 100);

    // Return route as generic solution representation.
    // Set model reference as NULL because this model is not a generic one.
    solution_t *sol = solution_new (NULL);
    solution_add_route (sol, route);

    return sol;
}


void tsp_test (bool verbose) {
    print_info ("* tsp: \n");

    // 1. manually created problem

    coord2d_t node_coords[] = {
        (coord2d_t) {0, 0},
        (coord2d_t) {3, 1},
        (coord2d_t) {2, 2},
        (coord2d_t) {1, 1.5},
        (coord2d_t) {4, 0.5},
        (coord2d_t) {5, 0}
    };
    size_t start_node_id = 0, end_node_id = 0;

    size_t num_nodes = sizeof (node_coords) / sizeof (coord2d_t);

    // Create generic model
    vrp_t *vrp = vrp_new ();

    // Set roadgraph

    vrp_set_coord_sys (vrp, CS_CARTESIAN2D);
    char *ext_id = malloc (16);
    for (size_t idx = 0; idx < num_nodes; idx++) {
        sprintf (ext_id, "node-%4zu", idx);
        size_t nid = vrp_add_node (vrp, ext_id, NR_CUSTOMER);
        vrp_set_node_coord (vrp, nid, node_coords[idx]);
    }
    vrp_generate_beeline_distances (vrp);

    // Add a vehicle
    sprintf (ext_id, "vehicle-%4d", 0);
    vrp_add_vehicle (vrp, ext_id, DOUBLE_MAX, start_node_id, end_node_id);

    // Create TSP model from generic model
    tsp_t *tsp = tsp_new_from (vrp);
    assert (tsp);

    // Solve
    solution_t *sol = tsp_solve (tsp);
    assert (sol);
    solution_print (sol);

    free (ext_id);
    tsp_free (&tsp);
    assert (tsp == NULL);
    vrp_free (&vrp);
    assert (vrp == NULL);
    solution_free (&sol);
    assert (sol == NULL);


    print_info ("OK\n");
}
