/*  =========================================================================
    tsp - implementation

    Copyright (c) 2016, Yang LIU <gloolar@gmail.com>
    =========================================================================
*/

#include "classes.h"


#define SMALL_NUM_NODES 60


struct _tsp_t {
    vrp_t *vrp; // reference of generic model
    route_t *template; // route template
    size_t start_node; // first node is fixed if specified
    size_t end_node; // last node is fixed if specified
    size_t unfixed_begin; // fist index of unfixed route slice
    size_t unfixed_end; // last index of unfixed route slice
    rng_t *rng;
};


// Check that round or one-way trip is to be optimized
static bool tsp_is_round_trip (tsp_t *self) {
    return (self->start_node != ID_NONE &&
            self->end_node != ID_NONE &&
            self->start_node == self->end_node);
}


// Number of different nodes for optimize
static size_t tsp_num_nodes (tsp_t *self) {
    return tsp_is_round_trip (self) ?
           listu_size (self->template) - 1 :
           listu_size (self->template);
}


// Evolution fitness callback: inverse of average cost over arcs
static double tsp_fitness (tsp_t *self, route_t *route) {
    double dist = route_total_distance (route, self->vrp,
                                        (vrp_arc_distance_t) vrp_arc_distance);
    return (dist > 0) ?
           (route_size (route) - 1) / dist :
           0.0;
}


// Evolution distance callback (Levenshtein distance)
static double tsp_genome_distance (tsp_t *self, route_t *r1, route_t *r2) {
    return arrayu_levenshtein_distance (route_node_array (r1), route_size (r1),
                                        route_node_array (r2), route_size (r2));
}


// Heuristic: Sweep algorithm
// @todo could be modified to generate more (realistic) routes
static listx_t *tsp_sweep (tsp_t *self, size_t max_expected) {
    listx_t *list = listx_new ();

    size_t route_len = route_size (self->template);
    size_t num_nodes_to_sort = self->unfixed_end - self->unfixed_begin + 1;

    // Get polar coordinates of nodes to sort
    coord2d_t *polars =
        (coord2d_t *) malloc (sizeof (coord2d_t) * num_nodes_to_sort);
    assert (polars);

    const coord2d_t *ref = (self->start_node != ID_NONE) ?
                           vrp_node_coord (self->vrp, self->start_node) :
                           NULL;

    size_t cnt = 0;
    for (size_t idx = self->unfixed_begin; idx <= self->unfixed_end; idx++) {
        size_t node_id = route_at (self->template, idx);
        polars[cnt] = coord2d_to_polar (vrp_node_coord (self->vrp, node_id),
                                        ref,
                                        vrp_coord_sys (self->vrp));
        polars[cnt].v1 = (double) node_id; // save ID in radius position
        cnt++;
    }

    // Sort nodes in ascending order of angle
    qsort (polars, num_nodes_to_sort, sizeof (coord2d_t),
           (comparator_t) coord2d_compare_polar_angle);

    // Make route
    listu_t *route = route_new (route_len);
    assert (route);
    if (self->start_node != SIZE_NONE)
        route_append_node (route, self->start_node);
    for (size_t idx = 0; idx < num_nodes_to_sort; idx++)
        route_append_node (route, (size_t) polars[idx].v1);
    if (self->end_node != SIZE_NONE)
        route_append_node (route, self->end_node);

    print_info ("route generated by sweep:\n");
    route_print (route);

    listx_append (list, route);
    return list;
}


// Heuristic: random permutation
static listx_t *tsp_random_permutation (tsp_t *self, size_t max_expected) {
    listx_t *list = listx_new ();

    // Duplate template and shuffle
    for (size_t cnt = 0; cnt < max_expected; cnt++) {
        route_t *route = route_dup (self->template);
        assert (route);
        route_shuffle (route, self->unfixed_begin, self->unfixed_end, self->rng);
        listx_append (list, route);
    }

    return list;
}


// Crossover: OX
static listx_t *tsp_ox (tsp_t *self, route_t *route1, route_t *route2) {
    assert (route_size (route1) == route_size (route2));
    route_t *r1 = route_dup (route1);
    route_t *r2 = route_dup (route2);

    route_ox (r1, r2, self->unfixed_begin, self->unfixed_end, self->rng);

    listx_t *list = listx_new ();
    listx_append (list, r1);
    listx_append (list, r2);
    return list;
}


// Local search: 2-opt
static double tsp_2_opt (tsp_t *self, route_t *route, bool exhaustive) {
    double saving = 0, ddist;
    bool improved = true;

    while (improved) {
        improved = false;
        // For each possible route sile
        for (size_t i = self->unfixed_begin; i < self->unfixed_end && !improved; i++) {
            for (size_t j = i + 1; j <= self->unfixed_end && !improved; j++) {
                ddist =
                    route_reverse_delta_distance (route, i, j,
                                                  self->vrp,
                                                  (vrp_arc_distance_t) vrp_arc_distance);
                if (ddist < 0) {
                    route_reverse (route, i, j);
                    saving -= ddist;
                    if (!exhaustive)
                        return saving;
                    improved = true;
                }
            }
        }
    }
    return saving;
}


// Local searcher for evolution: non-exhaustive 2-opt
static void tsp_local_search_for_evol (tsp_t *self, route_t *route) {
    tsp_2_opt (self, route, false);
}


// Post optimization: exhaustive 2-opt
static double tsp_post_optimize (tsp_t *self, route_t *route) {
    return tsp_2_opt (self, route, true);
}


// Solve small model
static solution_t *tsp_solve_small_model (tsp_t *self) {
    print_info ("solve a small model...\n");
    solution_t *sol = solution_new ();
    size_t num_nodes = tsp_num_nodes (self);

    // Case 1: no nodes
    if (num_nodes == 0)
        return sol; // empty solution

    // Case 2: one node
    // Case 3: two nodes, and at least one node is fixed
    if (num_nodes == 1 ||
          (num_nodes == 2 &&
          (self->start_node != ID_NONE || self->end_node != ID_NONE)) ) {
        route_t *route = route_dup (self->template);
        solution_append_route (sol, route);
        return sol;
    }

    // Other small cases: use local search to solve.
    route_t *route = route_dup (self->template);
    double route_cost =
        route_total_distance (route,
                              self->vrp,
                              (vrp_arc_distance_t) vrp_arc_distance);
    print_info ("route cost before local search: %.2f\n", route_cost);
    double saving = tsp_post_optimize (self, route);
    double improvement = saving / route_cost;
    route_cost = route_total_distance (route,
                                       self->vrp,
                                       (vrp_arc_distance_t) vrp_arc_distance);
    print_info ("route cost after local search: %.2f (%+.2f%% improved)\n",
                route_cost, improvement * 100);

    solution_append_route (sol, route);
    return sol;
}


// ----------------------------------------------------------------------------

tsp_t *tsp_new_from_generic (vrp_t *vrp) {
    assert (vrp);

    tsp_t *self = (tsp_t *) malloc (sizeof (tsp_t));
    assert (self);

    self->vrp = vrp;

    // Set start and end nodes
    assert (vrp_num_vehicles (vrp) == 1);
    size_t vehicle_id = listu_get (vrp_vehicles (vrp), 0);
    assert (vehicle_id != ID_NONE);

    self->start_node = vrp_vehicle_start_node_id (vrp, vehicle_id);
    self->end_node = vrp_vehicle_end_node_id (vrp, vehicle_id);

    // Make regularized route template: (start_node, ..., end_node)
    // Note that start or end node of vehicle may not be specified, then the
    // model is one-way and open ended.

    // Do not estimate the size, start with a trivial number.
    self->template = route_new (3);

    if (self->start_node != ID_NONE)
        listu_append (self->template, self->start_node);

    // Add nodes by scanning the pending requests (duplicate nodes removed)
    // For each request, add one of sender and receiver node.
    const listu_t *request_ids = vrp_pending_request_ids (vrp);
    size_t num_requests = listu_size (request_ids);
    for (size_t idx = 0; idx < num_requests; idx++) {
        size_t request_id = listu_get (request_ids, idx);
        size_t node_id = vrp_request_sender (vrp, request_id);
        if (node_id == ID_NONE)
            node_id = vrp_request_receiver (vrp, request_id);
        assert (node_id != ID_NONE);
        if (!listu_includes (self->template, node_id))
            listu_append (self->template, node_id);
    }

    if (self->end_node != ID_NONE &&
        !listu_includes (self->template, self->end_node))
        listu_append (self->template, self->end_node);

    self->unfixed_begin = (self->start_node != ID_NONE) ? 1 : 0;
    self->unfixed_end = route_size (self->template) -
                        ((self->end_node != ID_NONE) ? 2 : 1);
    assert (self->unfixed_begin <= self->unfixed_end);

    print_info ("tsp derived from generic VRP model.\n");
    print_info ("route template: #nodes: %zu, %s trip, start: %s, end: %s\n",
                tsp_num_nodes (self),
                tsp_is_round_trip (self) ? "round" : "one-way",
                (self->start_node != ID_NONE) ? "set" : "none",
                (self->end_node != ID_NONE) ? "set" : "none");
    route_print (self->template);

    self->rng = rng_new ();
    return self;
}


void tsp_free (tsp_t **self_p) {
    assert (self_p);
    if (*self_p) {
        tsp_t *self = *self_p;
        route_free (&self->template);
        rng_free (&self->rng);
        free (self);
        *self_p = NULL;
    }
    print_info ("tsp freed.\n");
}


solution_t *tsp_solve (tsp_t *self) {
    assert (self);

    // Deal with small numboer of nodes
    if (tsp_num_nodes (self) <= SMALL_NUM_NODES)
        return tsp_solve_small_model (self);

    // Create evolution object
    evol_t *evol = evol_new (self);

    // Set all necessary callbacks of evol
    evol_set_genome_destructor (evol, (destructor_t) route_free);
    evol_set_genome_printer (evol, (printer_t) route_print);
    evol_set_fitness_assessor (evol, (evol_fitness_assessor_t) tsp_fitness);
    evol_set_distance_assessor (evol, (evol_distance_assessor_t) tsp_genome_distance);

    if (vrp_coord_sys (self->vrp) != CS_NONE)
        evol_register_heuristic (evol,
                                 (evol_heuristic_t) tsp_sweep,
                                 false,
                                 1);

    size_t num_free_nodes = route_size (self->template);
    num_free_nodes -= (self->start_node != ID_NONE) ? 1 : 0;
    num_free_nodes -= (self->end_node != ID_NONE) ? 1 : 0;
    evol_register_heuristic (evol,
                             (evol_heuristic_t) tsp_random_permutation,
                             true,
                             factorial (num_free_nodes));

    evol_register_crossover (evol, (evol_crossover_t) tsp_ox);
    evol_register_educator (evol, (evol_educator_t) tsp_local_search_for_evol);

    // Run evolution
    evol_run (evol);

    // Get best genome (route)
    route_t *route = route_dup ((route_t *) evol_best_genome (evol));
    assert (route);

    // Destroy evolution object
    evol_free (&evol);

    double route_cost =
        route_total_distance (route,
                              self->vrp,
                              (vrp_arc_distance_t) vrp_arc_distance);
    print_info ("route cost after evol: %.2f\n", route_cost);

    // Post optimization
    double saving = tsp_post_optimize (self, route);
    double improvement = saving / route_cost;
    route_cost = route_total_distance (route,
                                       self->vrp,
                                       (vrp_arc_distance_t) vrp_arc_distance);
    print_info ("route cost after post-optimization: %.2f\n", route_cost);
    print_info ("post-optimization improved: %.2f%%\n", improvement * 100);

    // Return route as generic solution representation.
    solution_t *sol = solution_new ();
    solution_append_route (sol, route);

    return sol;
}


void tsp_test (bool verbose) {
    print_info ("* tsp: \n");

    // 1. manually created problem

    coord2d_t node_coords[] = {
        (coord2d_t) {0, 0},
        (coord2d_t) {3, 1},
        (coord2d_t) {2, 2},
        (coord2d_t) {1, 1.5},
        (coord2d_t) {4, 0.5},
        (coord2d_t) {5, 0}
    };
    size_t start_node = 0, end_node = 0;

    size_t num_nodes = sizeof (node_coords) / sizeof (coord2d_t);

    // Create generic model
    vrp_t *vrp = vrp_new ();

    // Set roadgraph and add visiting request for each node
    vrp_set_coord_sys (vrp, CS_CARTESIAN2D);
    char *ext_id = malloc (16);
    for (size_t idx = 0; idx < num_nodes; idx++) {
        sprintf (ext_id, "node-%4zu", idx);
        size_t nid = vrp_add_node (vrp, ext_id);
        vrp_set_node_coord (vrp, nid, node_coords[idx]);

        sprintf (ext_id, "visit-%4zu", idx);
        vrp_add_request (vrp, ext_id, ID_NONE, nid, 0);
    }
    vrp_generate_beeline_distances (vrp);

    // Add a vehicle
    sprintf (ext_id, "vehicle-%4d", 0);
    vrp_add_vehicle (vrp, ext_id, DOUBLE_MAX, start_node, end_node);

    // Create TSP model from generic model
    tsp_t *tsp = tsp_new_from_generic (vrp);
    assert (tsp);

    // Solve
    solution_t *sol = tsp_solve (tsp);
    assert (sol);
    solution_print (sol);

    free (ext_id);
    tsp_free (&tsp);
    assert (tsp == NULL);
    vrp_free (&vrp);
    assert (vrp == NULL);
    solution_free (&sol);
    assert (sol == NULL);

    // 2. problem derived from generic model

    char filename[] =
        "benchmark/tsplib/tsp/berlin52.tsp";
        // "benchmark/tsplib/tsp/a280.tsp";

    vrp = vrp_new_from_file (filename);
    assert (vrp);

    printf ("#nodes: %zu\n", vrp_num_nodes (vrp));
    printf ("#vehicles: %zu\n", vrp_num_vehicles (vrp));

    sol = vrp_solve (vrp);
    solution_cal_set_total_distance (sol, vrp, (vrp_arc_distance_t) vrp_arc_distance);
    solution_print (sol);

    vrp_free (&vrp);
    assert (vrp == NULL);
    solution_free (&sol);
    assert (sol == NULL);

    print_info ("OK\n");
}
