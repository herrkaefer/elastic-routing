/*  =========================================================================
    tsp - implementation

    Copyright (c) 2016, Yang LIU <gloolar@gmail.com>

    This file is part of the Elastic Routing Project.
    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.
    =========================================================================
*/

#include "classes.h"


struct _tsp_t {
    vrp_t *vrp; // generic model

    // size_t num_nodes; // number of nodes
    listu_t *template; // route template
    size_t start_node_id;
    size_t end_node_id;
    // bool is_round_trip;

    rng_t *rng;
};


// Check that round or one-way trip is to be optimized
static bool tsp_is_round_trip (tsp_t *self) {
    return (self->start_node_id != ID_NONE &&
            self->end_node_id != ID_NONE &&
            self->start_node_id == self->end_node_id);
}


// Number of different nodes for optimize
static size_t tsp_num_nodes (tsp_t *self) {
    return tsp_is_round_trip (self) ?
           listu_size (self->template) - 1 :
           listu_size (self->template);
}


// ---------------------------------------------------------------------------
// Fitness callback: average cost over arcs
static double tsp_fitness (tsp_t *self, listu_t *route) {
    double cost = 0.0;
    size_t len = listu_size (route);
    if (len == 1)
        return cost;

    for (size_t i = 0; i < len-1; i++)
        cost += vrp_distance (self->vrp,
                              listu_get (route, i),
                              listu_get (route, i+1));

    assert (cost > 0);
    return (len-1)/cost;
}


// Distance callback (Levenshtein distance)
static double tsp_distance (tsp_t *self,
                            listu_t *r1,
                            listu_t *r2) {
    return arrayu_levenshtein_distance (listu_array (r1), listu_size (r1),
                                        listu_array (r2), listu_size (r2));
}


// Heuristic: Sweep algorithm
// @todo could be modified to generate more (realistic) routes
static listx_t *tsp_sweep (tsp_t *self, size_t max_expected) {
    listx_t *list = listx_new ();

    size_t route_size = listu_size (self->template);
    size_t start_idx = (self->start_node_id != ID_NONE) ? 1 : 0;
    size_t end_idx =
        (self->end_node_id != ID_NONE) ? (route_size-2) : (route_size-1);
    size_t num_nodes_to_sort = end_idx - start_idx + 1;

    // Get polar coordinates of nodes to sort
    coord2d_t *polars =
        (coord2d_t *) malloc (sizeof (coord2d_t) * num_nodes_to_sort);
    assert (polars);

    coord2d_t *ref = NULL;
    if (self->start_node_id != ID_NONE) {
        coord2d_t start_coord = vrp_node_coord (self->vrp, self->start_node_id);
        ref = &start_coord;
    }

    for (size_t idx = start_idx; idx <= end_idx; idx++) {
        size_t node_id = listu_get (self->template, idx);
        coord2d_t node_coord = vrp_node_coord (self->vrp, node_id);
        polars[idx] =
            coord2d_to_polar (&node_coord, ref, vrp_coord_sys (self->vrp));
        polars[idx].v1 = (double) node_id; // save ID in radius position
    }

    // Sort nodes in ascending order of angle
    qsort (polars, num_nodes_to_sort, sizeof (coord2d_t),
           (comparator_t) coord2d_compare_polar_angle);

    // Make route
    listu_t *route = listu_new (route_size);
    assert (route);
    if (self->start_node_id != SIZE_NONE)
        listu_append (route, self->start_node_id);
    for (size_t idx = 0; idx < num_nodes_to_sort; idx++)
        listu_append (route, (size_t) polars[idx].v1);
    if (self->end_node_id != SIZE_NONE)
        listu_append (route, self->end_node_id);

    print_info ("route generated by sweep:\n");
    listu_print (route);

    listx_append (list, route);
    return list;
}


// Heuristic: random generation
static listx_t *tsp_random_routes (tsp_t *self, size_t max_expected) {
    listx_t *list = listx_new ();

    size_t route_size = listu_size (self->template);
    size_t shuffle_start = (self->start_node_id != ID_NONE) ? 1 : 0;
    size_t shuffle_end =
        (self->end_node_id != ID_NONE) ? (route_size-2) : (route_size-1);
    assert (shuffle_start <= shuffle_end);

    for (size_t cnt = 0; cnt < max_expected; cnt++) {
        listu_t *route = listu_dup (self->template);
        assert (route);
        listu_shuffle_slice (route, shuffle_start, shuffle_end, self->rng);
        listx_append (list, route);
        // print_info ("random route:\n");
        // listu_print (route);
    }

    return list;
}


static void tsp_route_ox (tsp_t *self,
                           size_t *route1, size_t *route2,
                           size_t start, size_t end) {
    assert(start <= end);

    size_t i, j, k, tmp;
    size_t n = end - start + 1;
    size_t len_fix;
    size_t *P1 = route1 + start,
        *P2 = route2 + start;
    size_t pos_c1, pos_c2;

    i = rng_random_int (self->rng, 0, n);
    j = rng_random_int (self->rng, 0, n);

    if (i > j) {
        k = i;
        i = j;
        j = k;
    }
    len_fix = j - i + 1;

    // PRINT("\nP1: ");
    // print_route(P1, 0, n-1, NULL);
    // PRINT("P2: ");
    // print_route(P2, 0, n-1, NULL);
    // PRINT("\nfix segment: %d -> %d. route1: %d->%d, route2: %d->%d\n", i, j, P1[i], P1[j], P2[i], P2[j]);

    // circular
    size_t cnt = 0;
    for (cnt = 0, k = (j + 1) % n, pos_c1 = k, pos_c2 = k;
         cnt < n && (pos_c1 != i || pos_c2 != i);
         cnt++, k = (k + 1) % n) {
        // PRINT("n: %d, cnt: %d, k: %d, pos_c1: %d, pos_c2: %d\n", n, cnt, k, pos_c1, pos_c2);
        tmp = P1[k];
        if (pos_c1 != i && !arrayu_includes (P1+i, len_fix, P2[k])) {
            P1[pos_c1++] = P2[k];
            if (pos_c1 == n) pos_c1 = 0;
        }
        if (pos_c2 != i && !arrayu_includes (P2+i, len_fix, tmp)) {
            P2[pos_c2++] = tmp;
            if (pos_c2 == n) pos_c2 = 0;
        }
    }

    // PRINT("\nC1: ");
    // print_route(C1, 0, n-1, NULL);
    // PRINT("C2: ");
    // print_route(C2, 0, n-1, NULL);
}


// Crossover callback: OX
static listx_t *tsp_ox (tsp_t *self, listu_t *route1, listu_t *route2) {
    listx_t *list = listx_new ();

    size_t *r1 = listu_dump_array (route1);
    assert (r1);
    size_t *r2 = listu_dump_array (route2);
    assert (r2);

    size_t len1 = listu_size (route1);
    assert (len1 == listu_size (route2));

    size_t start_idx = self->start_node_id != SIZE_NONE ? 1 : 0;
    size_t end_idx = self->end_node_id != SIZE_NONE ? (len1-2) : (len1-1);
    // print_info ("start: %zu, end: %zu\n", start_idx, end_idx);

    tsp_route_ox (self, r1, r2, start_idx, end_idx);

    // arrayu_print (r1, len1);
    // arrayu_print (r2, len1);

    listu_t *child1 = listu_new_from_array (r1, len1);
    listu_t *child2 = listu_new_from_array (r2, len1);
    // listu_print (child1);
    // listu_print (child2);

    listx_append (list, child1);
    listx_append (list, child2);

    free (r1);
    free (r2);
    return list;
}


// ---------------------------------------------------------------------------
tsp_t *tsp_new_from (vrp_t *vrp) {
    assert (vrp);

    // Sub-model verification
    if (!vrp_is_tsp (vrp)) {
        print_error ("TSP submodel verification failed.\n");
        return NULL;
    }

    tsp_t *self = (tsp_t *) malloc (sizeof (tsp_t));
    assert (self);

    self->vrp = vrp;

    // Set start and end nodes
    size_t *vehicle_ids = vrp_vehicle_ids (vrp);
    assert (vehicle_ids);
    self->start_node_id = vrp_vehicle_start_node_id (vrp, vehicle_ids[0]);
    self->end_node_id = vrp_vehicle_end_node_id (vrp, vehicle_ids[0]);
    free (vehicle_ids);

    // Make regularized route template
    size_t num_nodes = vrp_num_nodes (vrp);
    self->template = listu_new (num_nodes + 1);
    size_t *node_ids = vrp_node_ids (vrp);
    assert (node_ids);

    if (self->start_node_id != ID_NONE)
        listu_append (self->template, self->start_node_id);

    for (size_t cnt = 0; cnt < num_nodes; cnt++) {
        if (node_ids[cnt] != self->start_node_id &&
            node_ids[cnt] != self->end_node_id) {
            listu_append (self->template, node_ids[cnt]);
        }
    }

    if (self->end_node_id != ID_NONE)
        listu_append (self->template, self->end_node_id);

    free (node_ids);

    print_info ("tsp created from generic VRP model.\n");
    print_info ("route template: #nodes: %zu, %s trip\n",
                tsp_num_nodes (self),
                tsp_is_round_trip (self) ? "round" : "one-way");
    listu_print (self->template);

    return self;
}


void tsp_free (tsp_t **self_p) {
    assert (self_p);
    if (*self_p) {
        tsp_t *self = *self_p;

        listu_free (&self->template);

        free (self);
        *self_p = NULL;
    }
    print_info ("tsp freed.\n");
}


listu_t *tsp_solve (tsp_t *self) {
    assert (self);

    // Create evolution object
    evol_t *evol = evol_new ();

    // Set context
    evol_set_context (evol, self);

    // Set all necessary callbacks
    evol_set_genome_destructor (evol, (destructor_t) listu_free);
    evol_set_genome_printer (evol, (printer_t) listu_print);
    evol_set_fitness_assessor (evol, (evol_fitness_assessor_t) tsp_fitness);
    evol_set_distance_assessor (evol, (evol_distance_assessor_t) tsp_distance);
    evol_register_heuristic (evol,
                             (evol_heuristic_t) tsp_sweep,
                             false,
                             1);
    // size_t max_random_routes = factorial (listu_size (self->template)-2);
    // print_debug("");
    // print_info ("num_nodes: %zu, max random routes: %zu\n",
    //     listu_size (self->template)-2, max_random_routes);
    evol_register_heuristic (evol,
                             (evol_heuristic_t) tsp_random_routes,
                             true,
                             factorial (listu_size (self->template)-2));
    evol_register_crossover (evol, (evol_crossover_t) tsp_ox);

    // Run evolution
    evol_run (evol);

    // Get results
    listu_t *result = listu_dup ((listu_t *) evol_best_genome (evol));
    assert (result);

    // Destroy evolution object
    evol_free (&evol);

    // Post optimization
    // 2-opt, 3-opt, etc.


    return result;

}





void tsp_test (bool verbose) {
    print_info (" * tsp: \n");
    // tsp_t *tsp = tsp_new_from_file ("testdata/A-n32-k5.vrp");
    // assert (tsp);
    // print_info ("N: %d, K: %d, Q: %f\n",
    //     tsp_num_customers (tsp),
    //     tsp_num_vehicles (tsp),
    //     tsp_capacity (tsp));

    // // ...
    // tsp_free (&tsp);
    print_info ("OK\n");
}
